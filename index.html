<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BLE Live Plotter</title>
  <style>
    :root {
      --bg: #0b0f19;
      --card: #121a2a;
      --text: #e7eefc;
      --muted: #a9b6d3;
      --accent: #67b7ff;
      --danger: #ff6b6b;
      --ok: #36d399;

      /* Plot theme defaults (dark) */
      --plot-bg: #070b13;
      --plot-grid: rgba(255,255,255,0.10);
      --plot-axis: rgba(255,255,255,0.20);
      --plot-text: rgba(255,255,255,0.75);
      --plot-trace: rgba(103,183,255,0.95);
    }

    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background: var(--bg); color: var(--text); }
    header { padding: 14px 16px; background: rgba(255,255,255,0.03); border-bottom: 1px solid rgba(255,255,255,0.06); }
    header h1 { font-size: 16px; margin: 0; font-weight: 650; }
    header p { margin: 6px 0 0; color: var(--muted); font-size: 12px; }

    main { padding: 16px; display: grid; gap: 12px; max-width: 980px; margin: 0 auto; }
    .card { background: var(--card); border: 1px solid rgba(255,255,255,0.06); border-radius: 14px; padding: 12px; box-shadow: 0 8px 24px rgba(0,0,0,0.2); }

    .controls { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
    button { appearance: none; border: 1px solid rgba(255,255,255,0.12); background: rgba(255,255,255,0.06); color: var(--text);
      padding: 10px 12px; border-radius: 12px; font-weight: 650; cursor: pointer; }
    button.primary { border-color: rgba(103,183,255,0.6); background: rgba(103,183,255,0.15); }
    button.danger { border-color: rgba(255,107,107,0.55); background: rgba(255,107,107,0.12); }
    button:disabled { opacity: 0.45; cursor: not-allowed; }

    .small { font-size: 12px; color: var(--muted); }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }

    .pill { display: inline-flex; align-items: center; gap: 8px; padding: 6px 10px; border-radius: 999px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.08); }
    .dot { width: 8px; height: 8px; border-radius: 50%; background: #666; }
    .dot.ok { background: var(--ok); }
    .dot.bad { background: var(--danger); }

    canvas { width: 100%; height: 360px; background: var(--plot-bg); border-radius: 12px; border: 1px solid rgba(255,255,255,0.06); touch-action: pan-y; }

    .kpi { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 10px; }
    .kpi .item { padding: 10px; border-radius: 12px; background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.06); }
    .kpi .label { font-size: 11px; color: var(--muted); }
    .kpi .value { font-size: 16px; font-weight: 750; margin-top: 4px; }

    .grid2 { display: grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 860px) { .grid2 { grid-template-columns: 1.2fr 0.8fr; } }

    input[type="number"] { width: 110px; padding: 9px 10px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.12); background: rgba(255,255,255,0.05); color: var(--text); }
    input[type="checkbox"] { transform: scale(1.15); }

    .footerbar { display:flex; flex-wrap:wrap; gap:10px; align-items:center; justify-content: space-between; }
    .footerbar .left, .footerbar .right { display:flex; flex-wrap:wrap; gap:10px; align-items:center; }

    a { color: var(--accent); text-decoration: none; }
  </style>
</head>
<body>
  <header>
    <h1>BLE Live Plotter (ANNA-B112)</h1>
    <p>Web Bluetooth realtime plot + CSV export. Parses <span class="mono">(timestamp, voltage)</span> float32 pairs.</p>
  </header>

  <main>
    <!-- PLOT FIRST (on top) -->
    <div class="card">
      <canvas id="plot" width="1400" height="480"></canvas>

      <div class="controls" style="margin-top:10px; justify-content: space-between;">
        <div class="controls tight">
          <button id="btnConnect" class="primary" type="button">Connect</button>
          <button id="btnDisconnect" class="danger" type="button" disabled>Disconnect</button>
          <span class="pill"><span id="statusDot" class="dot"></span><span id="statusText" class="small">Disconnected</span></span>
          <span class="pill"><span class="small">Device:</span><span id="deviceName" class="mono small">—</span></span>
        </div>
        <div class="controls tight">
          <button id="btnTheme" type="button">Plot: Dark</button>
          <button id="btnClear" type="button">Clear</button>
          <button id="btnCsv" type="button">Download CSV</button>
        </div>
      </div>

      <div class="controls" style="margin-top:10px;">
        <span class="small">Window (s):</span>
        <input id="winSeconds" type="number" min="1" max="120" step="1" value="10" />
        <span class="small">Auto-scale:</span>
        <input id="autoScale" type="checkbox" checked />
        <span class="small err" id="uiError" style="display:none;"></span>
      </div>
      <div class="small" style="margin-top:10px; line-height:1.45;">
        UUIDs: <span class="mono">Service</span> <span class="mono">cddf1000-30f7-4671-8b43-5e40ba53514a</span> • <span class="mono">Notify</span> <span class="mono">cddf1002-30f7-4671-8b43-5e40ba53514a</span><br/>
        Packet parsing: supports <span class="mono">8, 16, 24, ...</span> bytes per notification (multiple samples packed: 8 bytes each).
      </div>
    </div>

    <div class="grid2">
      <div class="card">
        <div class="kpi">
          <div class="item">
            <div class="label">Samples / s (approx)</div>
            <div class="value" id="kpiRate">—</div>
          </div>
          <div class="item">
            <div class="label">Latest voltage</div>
            <div class="value" id="kpiV">—</div>
          </div>
          <div class="item">
            <div class="label">Latest timestamp</div>
            <div class="value" id="kpiT">—</div>
          </div>
          <div class="item">
            <div class="label">Last packet (hex)</div>
            <div class="value mono" id="kpiHex" style="font-size: 12px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">—</div>
          </div>
        </div>

        <hr style="border: none; border-top: 1px solid rgba(255,255,255,0.08); margin: 14px 0;" />

        <div class="small" style="line-height:1.55;">
          <div style="font-weight:700; margin-bottom:6px;">Phone requirements</div>
          • Android: Chrome/Edge works. Must be served from <span class="mono">https://</span> or <span class="mono">http://localhost</span>.<br/>
          • iOS Safari: no Web Bluetooth.
        </div>
      </div>

      <!-- CONTROLS LAST (buttons at the end / bottom) -->
      <div class="card">
        <div class="controls" style="margin-bottom:10px;">
          <button id="btnConnect" class="primary">Connect</button>
          <button id="btnDisconnect" class="danger" disabled>Disconnect</button>
          <span class="pill"><span id="statusDot" class="dot"></span><span id="statusText" class="small">Disconnected</span></span>
          <span class="pill"><span class="small">Device:</span><span id="deviceName" class="mono small">—</span></span>
        </div>

        <div class="footerbar">
          <div class="left">
            <span class="small">Window (s):</span>
            <input id="winSeconds" type="number" min="1" max="120" step="1" value="10" />
            <span class="small">Auto-scale:</span>
            <input id="autoScale" type="checkbox" checked />
          </div>
          <div class="right">
            <button id="btnTheme">Plot: Dark</button>
            <button id="btnClear">Clear</button>
            <button id="btnCsv">Download CSV</button>
          </div>
        </div>

        <div class="small" style="margin-top:12px; line-height:1.5;">
          If you see fewer points than expected: this viewer now (1) parses multiple samples per BLE notification, and (2) decouples drawing from BLE events (draws at ~60fps).
        </div>
      </div>
    </div>
  </main>

<script>
// If Connect "does nothing", this script will show a visible error line under the plot.

const SERVICE_UUID = 'cddf1000-30f7-4671-8b43-5e40ba53514a';
const DATA_CHAR_UUID = 'cddf1002-30f7-4671-8b43-5e40ba53514a';

const el = (id) => document.getElementById(id);

const btnConnect = el('btnConnect');
const btnDisconnect = el('btnDisconnect');
const btnClear = el('btnClear');
const btnCsv = el('btnCsv');
const btnTheme = el('btnTheme');

const statusDot = el('statusDot');
const statusText = el('statusText');
const deviceNameEl = el('deviceName');
const winSecondsEl = el('winSeconds');
const autoScaleEl = el('autoScale');
const uiError = el('uiError');

const kpiRate = el('kpiRate');
const kpiV = el('kpiV');
const kpiT = el('kpiT');
const kpiHex = el('kpiHex');

const canvas = el('plot');
const ctx = canvas?.getContext('2d');

function showUiError(msg) {
  if (!uiError) { alert(msg); return; }
  uiError.style.display = 'inline';
  uiError.textContent = msg;
}

function clearUiError() {
  if (!uiError) return;
  uiError.style.display = 'none';
  uiError.textContent = '';
}

function setStatus(ok, msg) {
  statusDot?.classList.toggle('ok', !!ok);
  statusDot?.classList.toggle('bad', ok === false);
  if (statusText) statusText.textContent = msg;
}

function supportsWebBluetooth() {
  return !!navigator.bluetooth;
}

// Plot theme
let plotTheme = 'dark';
function applyPlotTheme() {
  if (plotTheme === 'dark') {
    document.documentElement.style.setProperty('--plot-bg', '#070b13');
    document.documentElement.style.setProperty('--plot-grid', 'rgba(255,255,255,0.10)');
    document.documentElement.style.setProperty('--plot-axis', 'rgba(255,255,255,0.20)');
    document.documentElement.style.setProperty('--plot-text', 'rgba(255,255,255,0.78)');
    document.documentElement.style.setProperty('--plot-trace', 'rgba(103,183,255,0.95)');
    if (btnTheme) btnTheme.textContent = 'Plot: Dark';
  } else {
    document.documentElement.style.setProperty('--plot-bg', '#ffffff');
    document.documentElement.style.setProperty('--plot-grid', 'rgba(0,0,0,0.12)');
    document.documentElement.style.setProperty('--plot-axis', 'rgba(0,0,0,0.22)');
    document.documentElement.style.setProperty('--plot-text', 'rgba(0,0,0,0.78)');
    document.documentElement.style.setProperty('--plot-trace', 'rgba(10,60,140,0.95)');
    if (btnTheme) btnTheme.textContent = 'Plot: Light';
  }
  requestDraw();
}

// Data
const session = { t: [], v: [] };
let times = [];
let volts = [];
let startIdx = 0;
let sampleTimesMs = [];

// BLE
let device = null;
let server = null;
let dataChar = null;

// Render throttle
let drawPending = false;
function requestDraw() {
  if (drawPending || !ctx) return;
  drawPending = true;
  requestAnimationFrame(() => {
    drawPending = false;
    draw();
  });
}

function toHex(u8) {
  let s = '';
  for (const b of u8) s += b.toString(16).padStart(2,'0');
  return s;
}

function addSample(t, v) {
  session.t.push(t);
  session.v.push(v);

  times.push(t);
  volts.push(v);

  const winS = Math.max(1, Math.min(120, Number(winSecondsEl?.value || 10)));
  const tMin = t - winS;
  while (startIdx < times.length && times[startIdx] < tMin) startIdx++;

  if (startIdx > 4000) {
    times = times.slice(startIdx);
    volts = volts.slice(startIdx);
    startIdx = 0;
  }

  const nowMs = performance.now();
  sampleTimesMs.push(nowMs);
  const cutoff = nowMs - 2000;
  while (sampleTimesMs.length && sampleTimesMs[0] < cutoff) sampleTimesMs.shift();

  const rate = sampleTimesMs.length / 2;
  if (kpiRate) kpiRate.textContent = isFinite(rate) ? rate.toFixed(1) : '—';
  if (kpiV) kpiV.textContent = isFinite(v) ? v.toFixed(4) + ' V' : '—';
  if (kpiT) kpiT.textContent = isFinite(t) ? t.toFixed(3) + ' s' : '—';
}

function onNotification(event) {
  const dv = event?.target?.value;
  if (!dv || dv.byteLength < 8) return;

  const bytes = new Uint8Array(dv.buffer.slice(dv.byteOffset, dv.byteOffset + dv.byteLength));
  if (kpiHex) kpiHex.textContent = toHex(bytes);

  // Parse multiple samples packed into one notification (8 bytes per sample)
  const n = Math.floor(dv.byteLength / 8);
  for (let i = 0; i < n; i++) {
    const off = i * 8;
    const t = dv.getFloat32(off + 0, true);
    const v = dv.getFloat32(off + 4, true);
    addSample(t, v);
  }

  requestDraw();
}

function clearData() {
  session.t.length = 0;
  session.v.length = 0;
  times = [];
  volts = [];
  startIdx = 0;
  sampleTimesMs = [];

  if (kpiRate) kpiRate.textContent = '—';
  if (kpiV) kpiV.textContent = '—';
  if (kpiT) kpiT.textContent = '—';
  if (kpiHex) kpiHex.textContent = '—';

  draw(true);
}

function downloadCSV() {
  if (!session.t.length) { alert('No data to export yet.'); return; }
  const lines = ['timestamp_s,voltage_V'];
  for (let i = 0; i < session.t.length; i++) lines.push(`${session.t[i]},${session.v[i]}`);
  const blob = new Blob([lines.join('\n')], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  const ts = new Date().toISOString().replace(/[:.]/g,'-');
  a.download = `ble_samples_${ts}.csv`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

function draw(clearOnly=false) {
  if (!ctx || !canvas) return;

  const w = canvas.width;
  const h = canvas.height;
  const padL = 64, padR = 14, padT = 16, padB = 42;

  const css = getComputedStyle(document.documentElement);
  ctx.clearRect(0, 0, w, h);
  ctx.fillStyle = css.getPropertyValue('--plot-bg').trim();
  ctx.fillRect(0, 0, w, h);

  const count = Math.max(0, times.length - startIdx);
  const txt = css.getPropertyValue('--plot-text').trim();

  if (clearOnly || count < 2) {
    ctx.fillStyle = txt;
    ctx.font = '16px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
    ctx.fillText('No data yet. Connect and start notifications…', 18, 34);
    return;
  }

  const t0 = times[startIdx];
  const t1 = times[times.length - 1];

  let vMin, vMax;
  if (autoScaleEl?.checked) {
    vMin = Infinity; vMax = -Infinity;
    for (let i = startIdx; i < volts.length; i++) {
      const v = volts[i];
      if (v < vMin) vMin = v;
      if (v > vMax) vMax = v;
    }
    const span = (vMax - vMin);
    const pad = (span * 0.12) || 0.02;
    vMin -= pad; vMax += pad;
  } else {
    vMin = 0.0; vMax = 3.3;
  }
  if (vMax - vMin < 1e-9) vMax = vMin + 1e-6;
  if (t1 - t0 < 1e-9) return;

  const plotW = w - padL - padR;
  const plotH = h - padT - padB;

  // Grid
  ctx.strokeStyle = css.getPropertyValue('--plot-grid').trim();
  ctx.lineWidth = 1;

  const yTicks = 5;
  for (let i = 0; i <= yTicks; i++) {
    const y = padT + (plotH * i) / yTicks;
    ctx.beginPath();
    ctx.moveTo(padL, y);
    ctx.lineTo(padL + plotW, y);
    ctx.stroke();
  }

  const xTicks = 5;
  for (let i = 0; i <= xTicks; i++) {
    const x = padL + (plotW * i) / xTicks;
    ctx.beginPath();
    ctx.moveTo(x, padT);
    ctx.lineTo(x, padT + plotH);
    ctx.stroke();
  }

  // Axes
  ctx.strokeStyle = css.getPropertyValue('--plot-axis').trim();
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(padL, padT);
  ctx.lineTo(padL, padT + plotH);
  ctx.lineTo(padL + plotW, padT + plotH);
  ctx.stroke();

  // Labels
  ctx.fillStyle = txt;
  ctx.font = '13px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';

  for (let i = 0; i <= yTicks; i++) {
    const frac = 1 - (i / yTicks);
    const v = vMin + frac * (vMax - vMin);
    const y = padT + (plotH * i) / yTicks;
    ctx.fillText(v.toFixed(3), 10, y + 4);
  }
  ctx.fillText('Voltage (V)', 10, 14);

  for (let i = 0; i <= xTicks; i++) {
    const frac = i / xTicks;
    const t = t0 + frac * (t1 - t0);
    const x = padL + (plotW * i) / xTicks;
    ctx.fillText(t.toFixed(2), x - 12, padT + plotH + 22);
  }
  ctx.fillText('Time (s)', padL + plotW - 70, padT + plotH + 38);

  // Trace
  ctx.strokeStyle = css.getPropertyValue('--plot-trace').trim();
  ctx.lineWidth = 2;
  ctx.beginPath();

  const maxDrawPoints = Math.min(4000, count);
  const step = Math.max(1, Math.floor(count / maxDrawPoints));

  let first = true;
  for (let i = startIdx; i < times.length; i += step) {
    const x = padL + ((times[i] - t0) / (t1 - t0)) * plotW;
    const y = padT + (1 - (volts[i] - vMin) / (vMax - vMin)) * plotH;
    if (first) { ctx.moveTo(x, y); first = false; }
    else ctx.lineTo(x, y);
  }
  ctx.stroke();

  ctx.fillStyle = txt;
  ctx.fillText(`Window: ${(t1 - t0).toFixed(2)} s • Points: ${count} (draw step=${step})`, padL, 14);
}

async function disconnect() {
  try {
    if (dataChar) {
      try { await dataChar.stopNotifications(); } catch (_) {}
      dataChar.removeEventListener('characteristicvaluechanged', onNotification);
    }
  } finally {
    dataChar = null;
    server = null;
    if (device && device.gatt && device.gatt.connected) device.gatt.disconnect();
    setStatus(false, 'Disconnected');
    if (btnDisconnect) btnDisconnect.disabled = true;
    if (btnConnect) btnConnect.disabled = false;
    if (deviceNameEl) deviceNameEl.textContent = '—';
  }
}

async function connect() {
  clearUiError();

  if (!supportsWebBluetooth()) {
    showUiError('Web Bluetooth not supported (use Android Chrome/Edge).');
    return;
  }

  // Must be user-gesture initiated
  clearData();

  try {
    setStatus(null, 'Opening device picker…');

    device = await navigator.bluetooth.requestDevice({
      filters: [{ services: [SERVICE_UUID] }],
      optionalServices: [SERVICE_UUID]
    });

    if (deviceNameEl) deviceNameEl.textContent = device.name || '(unnamed)';

    device.addEventListener('gattserverdisconnected', () => {
      setStatus(false, 'Disconnected');
      if (btnDisconnect) btnDisconnect.disabled = true;
      if (btnConnect) btnConnect.disabled = false;
    });

    setStatus(null, 'Connecting…');
    server = await device.gatt.connect();

    setStatus(null, 'Discovering services…');
    const service = await server.getPrimaryService(SERVICE_UUID);

    setStatus(null, 'Subscribing…');
    dataChar = await service.getCharacteristic(DATA_CHAR_UUID);

    await dataChar.startNotifications();
    dataChar.addEventListener('characteristicvaluechanged', onNotification);

    setStatus(true, 'Connected + streaming');
    if (btnDisconnect) btnDisconnect.disabled = false;
    if (btnConnect) btnConnect.disabled = true;

    requestDraw();
  } catch (err) {
    console.error(err);
    setStatus(false, 'Error');
    showUiError('Connect failed: ' + (err?.message || err));
    if (btnDisconnect) btnDisconnect.disabled = true;
    if (btnConnect) btnConnect.disabled = false;
    await disconnect();
  }
}

function bindOrError() {
  const missing = [];
  if (!btnConnect) missing.push('#btnConnect');
  if (!btnDisconnect) missing.push('#btnDisconnect');
  if (!canvas || !ctx) missing.push('#plot');
  if (missing.length) {
    showUiError('UI missing: ' + missing.join(', '));
    return;
  }

  btnConnect.addEventListener('click', connect);
  btnConnect.onclick = connect;

  btnDisconnect.addEventListener('click', disconnect);
  btnDisconnect.onclick = disconnect;

  btnClear?.addEventListener('click', clearData);
  if (btnClear) btnClear.onclick = clearData;

  btnCsv?.addEventListener('click', downloadCSV);
  if (btnCsv) btnCsv.onclick = downloadCSV;

  btnTheme?.addEventListener('click', () => {
    plotTheme = (plotTheme === 'dark') ? 'light' : 'dark';
    applyPlotTheme();
  });

  setStatus(false, 'Disconnected');
  applyPlotTheme();
  draw(true);
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', bindOrError);
} else {
  bindOrError();
}
</script>
</body>
</html>
