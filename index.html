<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BLE Live Plotter</title>
  <style>
    :root {
      --bg: #0b0f19;
      --card: #121a2a;
      --text: #e7eefc;
      --muted: #a9b6d3;
      --accent: #67b7ff;
      --danger: #ff6b6b;
      --ok: #36d399;

      /* Plot theme defaults (dark) */
      --plot-bg: #070b13;
      --plot-grid: rgba(255,255,255,0.10);
      --plot-axis: rgba(255,255,255,0.20);
      --plot-text: rgba(255,255,255,0.75);
      --plot-trace: rgba(103,183,255,0.95);
    }

    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background: var(--bg); color: var(--text); }
    header { padding: 14px 16px; background: rgba(255,255,255,0.03); border-bottom: 1px solid rgba(255,255,255,0.06); }
    header h1 { font-size: 16px; margin: 0; font-weight: 650; }
    header p { margin: 6px 0 0; color: var(--muted); font-size: 12px; }

    main { padding: 16px; display: grid; gap: 12px; max-width: 980px; margin: 0 auto; }
    .card { background: var(--card); border: 1px solid rgba(255,255,255,0.06); border-radius: 14px; padding: 12px; box-shadow: 0 8px 24px rgba(0,0,0,0.2); }

    .controls { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
    button { appearance: none; border: 1px solid rgba(255,255,255,0.12); background: rgba(255,255,255,0.06); color: var(--text);
      padding: 10px 12px; border-radius: 12px; font-weight: 650; cursor: pointer; }
    button.primary { border-color: rgba(103,183,255,0.6); background: rgba(103,183,255,0.15); }
    button.danger { border-color: rgba(255,107,107,0.55); background: rgba(255,107,107,0.12); }
    button:disabled { opacity: 0.45; cursor: not-allowed; }

    .small { font-size: 12px; color: var(--muted); }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }

    .pill { display: inline-flex; align-items: center; gap: 8px; padding: 6px 10px; border-radius: 999px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.08); }
    .dot { width: 8px; height: 8px; border-radius: 50%; background: #666; }
    .dot.ok { background: var(--ok); }
    .dot.bad { background: var(--danger); }

    canvas { width: 100%; height: 360px; background: var(--plot-bg); border-radius: 12px; border: 1px solid rgba(255,255,255,0.06); touch-action: pan-y; }

    .kpi { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 10px; }
    .kpi .item { padding: 10px; border-radius: 12px; background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.06); }
    .kpi .label { font-size: 11px; color: var(--muted); }
    .kpi .value { font-size: 16px; font-weight: 750; margin-top: 4px; }

    .grid2 { display: grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 860px) { .grid2 { grid-template-columns: 1.2fr 0.8fr; } }

    input[type="number"] { width: 110px; padding: 9px 10px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.12); background: rgba(255,255,255,0.05); color: var(--text); }
    input[type="checkbox"] { transform: scale(1.15); }

    .footerbar { display:flex; flex-wrap:wrap; gap:10px; align-items:center; justify-content: space-between; }
    .footerbar .left, .footerbar .right { display:flex; flex-wrap:wrap; gap:10px; align-items:center; }

    a { color: var(--accent); text-decoration: none; }
  </style>
</head>
<body>
  <header>
    <h1>BLE Live Plotter (ANNA-B112)</h1>
    <p>Web Bluetooth realtime plot + CSV export. Parses <span class="mono">(timestamp, voltage)</span> float32 pairs.</p>
  </header>

  <main>
    <!-- PLOT FIRST (on top) -->
    <div class="card">
      <canvas id="plot" width="1400" height="480"></canvas>

      <div class="controls" style="margin-top:10px; justify-content: space-between;">
        <div class="controls tight">
          <button id="btnConnect" class="primary" type="button">Connect</button>
          <button id="btnDisconnect" class="danger" type="button" disabled>Disconnect</button>
          <span class="pill"><span id="statusDot" class="dot"></span><span id="statusText" class="small">Disconnected</span></span>
          <span class="pill"><span class="small">Device:</span><span id="deviceName" class="mono small">—</span></span>
        </div>
        <div class="controls tight">
          <button id="btnTheme" type="button">Plot: Dark</button>
          <button id="btnClear" type="button">Clear</button>
          <button id="btnCsv" type="button">Download CSV</button>
        </div>
      </div>

      <div class="controls" style="margin-top:10px;">
        <span class="small">Window (s):</span>
        <input id="winSeconds" type="number" min="1" max="120" step="1" value="10" />
        <span class="small">Auto-scale:</span>
        <input id="autoScale" type="checkbox" checked />
        <span class="small" id="uiError" style="display:none; color:#ffd1d1;"></span>
      </div>

      <!-- Baseline-removed waveform (processed) -->
      <div class="small" style="margin-top:12px; margin-bottom:6px;">Processed (baseline removed, shifted to ≥ 0)</div>
      <canvas id="plotProc" width="1400" height="300" style="height:260px;"></canvas>
      <div class="small" style="margin-top:10px; line-height:1.45;">
        UUIDs: <span class="mono">Service</span> <span class="mono">cddf1000-30f7-4671-8b43-5e40ba53514a</span> • <span class="mono">Notify</span> <span class="mono">cddf1002-30f7-4671-8b43-5e40ba53514a</span><br/>
        Packet parsing: supports <span class="mono">8, 16, 24, ...</span> bytes per notification (multiple samples packed: 8 bytes each).
      </div>
    </div>

    <div class="grid2">
      <div class="card">
        <div class="kpi">
          <div class="item">
            <div class="label">Samples / s (approx)</div>
            <div class="value" id="kpiRate">—</div>
          </div>
          <div class="item">
            <div class="label">Latest voltage</div>
            <div class="value" id="kpiV">—</div>
          </div>
          <div class="item">
            <div class="label">Latest timestamp</div>
            <div class="value" id="kpiT">—</div>
          </div>
          <div class="item">
            <div class="label">Last packet (hex)</div>
            <div class="value mono" id="kpiHex" style="font-size: 12px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">—</div>
          </div>
        </div>

        <hr style="border: none; border-top: 1px solid rgba(255,255,255,0.08); margin: 14px 0;" />

        <div class="small" style="line-height:1.55;">
          <div style="font-weight:700; margin-bottom:6px;">Phone requirements</div>
          • Android: Chrome/Edge works. Must be served from <span class="mono">https://</span> or <span class="mono">http://localhost</span>.<br/>
          • iOS Safari: no Web Bluetooth.
        </div>
      </div>
    <div class="grid2">
      <div class="card">
        <div class="kpi">
          <div class="item">
            <div class="label">Samples / s (approx)</div>
            <div class="value" id="kpiRate">—</div>
          </div>
          <div class="item">
            <div class="label">Latest voltage</div>
            <div class="value" id="kpiV">—</div>
          </div>
          <div class="item">
            <div class="label">Latest timestamp</div>
            <div class="value" id="kpiT">—</div>
          </div>
          <div class="item">
            <div class="label">Last packet (hex)</div>
            <div class="value mono" id="kpiHex" style="font-size: 12px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">—</div>
          </div>
        </div>

        <hr style="border: none; border-top: 1px solid rgba(255,255,255,0.08); margin: 14px 0;" />

        <div class="small" style="line-height:1.55;">
          <div style="font-weight:700; margin-bottom:6px;">Phone requirements</div>
          • Android: Chrome/Edge works. Must be served from <span class="mono">https://</span> or <span class="mono">http://localhost</span>.<br/>
          • iOS Safari: no Web Bluetooth.
        </div>
      </div>

      <div class="card">
        <div class="small" style="line-height:1.55;">
          <div style="font-weight:700; margin-bottom:6px;">Multi-device</div>
          Tap <span class="mono">Connect</span> to connect device #1, then tap <span class="mono">Connect #2</span> to connect a second device.
          Both waveforms will overlay in the same plot, and the processed plot shows baseline-removed versions.
        </div>
      </div>
    </div>
  </main>

<script>
// Multi-device BLE plotter (2 devices) + baseline-removed plot.

const SERVICE_UUID = 'cddf1000-30f7-4671-8b43-5e40ba53514a';
const DATA_CHAR_UUID = 'cddf1002-30f7-4671-8b43-5e40ba53514a';

const el = (id) => document.getElementById(id);

// Buttons / UI (single set)
const btnConnect = el('btnConnect');
const btnDisconnect = el('btnDisconnect');
const btnClear = el('btnClear');
const btnCsv = el('btnCsv');
const btnTheme = el('btnTheme');

const statusDot = el('statusDot');
const statusText = el('statusText');
const deviceNameEl = el('deviceName');
const winSecondsEl = el('winSeconds');
const autoScaleEl = el('autoScale');
const uiError = el('uiError');

const kpiRate = el('kpiRate');
const kpiV = el('kpiV');
const kpiT = el('kpiT');
const kpiHex = el('kpiHex');

const canvas = el('plot');
const ctx = canvas?.getContext('2d');
const canvasProc = el('plotProc');
const ctxProc = canvasProc?.getContext('2d');

// Add Connect #2 / Disconnect #2 buttons next to existing ones (no duplicate IDs)
const connect2 = document.createElement('button');
connect2.type = 'button';
connect2.textContent = 'Connect #2';
connect2.className = 'primary';
connect2.style.opacity = '0.95';

const disconnect2 = document.createElement('button');
disconnect2.type = 'button';
disconnect2.textContent = 'Disconnect #2';
disconnect2.className = 'danger';
disconnect2.disabled = true;

autoinsertMultiButtons();
function autoinsertMultiButtons() {
  // Put Connect #2 right after Connect, and Disconnect #2 right after Disconnect
  if (btnConnect?.parentElement) {
    btnConnect.parentElement.insertBefore(connect2, btnDisconnect); // between connect and disconnect
  }
  if (btnDisconnect?.parentElement) {
    btnDisconnect.parentElement.insertBefore(disconnect2, btnDisconnect.nextSibling);
  }
}

function showUiError(msg) {
  if (!uiError) { alert(msg); return; }
  uiError.style.display = 'inline';
  uiError.textContent = msg;
}
function clearUiError() {
  if (!uiError) return;
  uiError.style.display = 'none';
  uiError.textContent = '';
}

function setStatus(ok, msg) {
  statusDot?.classList.toggle('ok', !!ok);
  statusDot?.classList.toggle('bad', ok === false);
  if (statusText) statusText.textContent = msg;
}

function supportsWebBluetooth() {
  return !!navigator.bluetooth;
}

// Plot theme
let plotTheme = 'dark';
function applyPlotTheme() {
  if (plotTheme === 'dark') {
    document.documentElement.style.setProperty('--plot-bg', '#070b13');
    document.documentElement.style.setProperty('--plot-grid', 'rgba(255,255,255,0.10)');
    document.documentElement.style.setProperty('--plot-axis', 'rgba(255,255,255,0.20)');
    document.documentElement.style.setProperty('--plot-text', 'rgba(255,255,255,0.78)');
    document.documentElement.style.setProperty('--plot-trace', 'rgba(103,183,255,0.95)');
    if (btnTheme) btnTheme.textContent = 'Plot: Dark';
  } else {
    document.documentElement.style.setProperty('--plot-bg', '#ffffff');
    document.documentElement.style.setProperty('--plot-grid', 'rgba(0,0,0,0.12)');
    document.documentElement.style.setProperty('--plot-axis', 'rgba(0,0,0,0.22)');
    document.documentElement.style.setProperty('--plot-text', 'rgba(0,0,0,0.78)');
    document.documentElement.style.setProperty('--plot-trace', 'rgba(10,60,140,0.95)');
    if (btnTheme) btnTheme.textContent = 'Plot: Light';
  }
  requestDraw();
}

// ===== Data per device (0 and 1) =====
const DEV_N = 2;
const dev = Array.from({length: DEV_N}, () => ({
  device: null,
  server: null,
  dataChar: null,
  sessionT: [],
  sessionV: [],
  times: [],
  volts: [],
  startIdx: 0,
  sampleTimesMs: [],
  lastHex: '',
  lastT: NaN,
  lastV: NaN,
}));

// ===== Rendering throttle =====
let drawPending = false;
function requestDraw() {
  if (drawPending) return;
  drawPending = true;
  requestAnimationFrame(() => {
    drawPending = false;
    drawOverlay();
    drawProcessed();
  });
}

function toHex(u8) {
  let s = '';
  for (const b of u8) s += b.toString(16).padStart(2,'0');
  return s;
}

function addSample(idx, t, v) {
  const d = dev[idx];
  d.sessionT.push(t);
  d.sessionV.push(v);
  d.times.push(t);
  d.volts.push(v);
  d.lastT = t;
  d.lastV = v;

  // maintain time window (pointer)
  const winS = Math.max(1, Math.min(120, Number(winSecondsEl?.value || 10)));
  const tMin = t - winS;
  while (d.startIdx < d.times.length && d.times[d.startIdx] < tMin) d.startIdx++;

  if (d.startIdx > 4000) {
    d.times = d.times.slice(d.startIdx);
    d.volts = d.volts.slice(d.startIdx);
    d.startIdx = 0;
  }

  // sample rate estimate
  const nowMs = performance.now();
  d.sampleTimesMs.push(nowMs);
  const cutoff = nowMs - 2000;
  while (d.sampleTimesMs.length && d.sampleTimesMs[0] < cutoff) d.sampleTimesMs.shift();
}

function onNotificationFactory(idx) {
  return (event) => {
    const dv = event?.target?.value;
    if (!dv || dv.byteLength < 8) return;

    const bytes = new Uint8Array(dv.buffer.slice(dv.byteOffset, dv.byteOffset + dv.byteLength));
    dev[idx].lastHex = toHex(bytes);

    // Parse multiple samples packed into one notification (8 bytes per sample)
    const n = Math.floor(dv.byteLength / 8);
    for (let i = 0; i < n; i++) {
      const off = i * 8;
      const t = dv.getFloat32(off + 0, true);
      const v = dv.getFloat32(off + 4, true);
      addSample(idx, t, v);
    }

    // KPIs shown for device #1 by default; if #1 not connected, show #2.
    updateKPIs();
    requestDraw();
  };
}

function updateKPIs() {
  const primary = dev[0].device ? 0 : (dev[1].device ? 1 : 0);
  const d = dev[primary];

  const rate = (d.sampleTimesMs?.length || 0) / 2;
  if (kpiRate) kpiRate.textContent = isFinite(rate) ? rate.toFixed(1) : '—';
  if (kpiV) kpiV.textContent = isFinite(d.lastV) ? d.lastV.toFixed(4) + ' V' : '—';
  if (kpiT) kpiT.textContent = isFinite(d.lastT) ? d.lastT.toFixed(3) + ' s' : '—';
  if (kpiHex) kpiHex.textContent = d.lastHex || '—';

  // Show both names in header pill
  const n0 = dev[0].device?.name || '';
  const n1 = dev[1].device?.name || '';
  const label = [n0, n1].filter(Boolean).join(' + ') || '—';
  if (deviceNameEl) deviceNameEl.textContent = label;
}

function clearData() {
  for (let i = 0; i < DEV_N; i++) {
    dev[i].sessionT.length = 0;
    dev[i].sessionV.length = 0;
    dev[i].times = [];
    dev[i].volts = [];
    dev[i].startIdx = 0;
    dev[i].sampleTimesMs = [];
    dev[i].lastHex = '';
    dev[i].lastT = NaN;
    dev[i].lastV = NaN;
  }

  if (kpiRate) kpiRate.textContent = '—';
  if (kpiV) kpiV.textContent = '—';
  if (kpiT) kpiT.textContent = '—';
  if (kpiHex) kpiHex.textContent = '—';
  if (deviceNameEl) deviceNameEl.textContent = '—';

  drawOverlay(true);
  drawProcessed(true);
}

function downloadCSV() {
  const total = dev[0].sessionT.length + dev[1].sessionT.length;
  if (!total) { alert('No data to export yet.'); return; }

  // device,timestamp_s,voltage_V,processed_V
  const lines = ['device,timestamp_s,voltage_V,processed_V'];

  // Baseline removal uses median of window (robust) per device, computed per-sample using current window baseline.
  // For CSV simplicity, we export processed_V computed with baseline = median of LAST WINDOW.
  for (let i = 0; i < DEV_N; i++) {
    const name = dev[i].device?.name || `dev${i+1}`;
    const baseline = medianWindowBaseline(i);
    for (let k = 0; k < dev[i].sessionT.length; k++) {
      const t = dev[i].sessionT[k];
      const v = dev[i].sessionV[k];
      let p = v - baseline;
      if (!isFinite(p)) p = 0;
      lines.push(`${name},${t},${v},${p}`);
    }
  }

  const blob = new Blob([lines.join('\n')], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  const ts = new Date().toISOString().replace(/[:.]/g,'-');
  a.download = `ble_samples_${ts}.csv`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

function median(arr) {
  if (!arr.length) return NaN;
  const a = arr.slice().sort((x,y)=>x-y);
  const m = Math.floor(a.length/2);
  return (a.length % 2) ? a[m] : (a[m-1] + a[m]) / 2;
}

function medianWindowBaseline(idx) {
  const d = dev[idx];
  const n = d.times.length - d.startIdx;
  if (n < 3) return NaN;
  // Use the last ~2 seconds (or full window if smaller) for baseline
  const t1 = d.times[d.times.length - 1];
  const span = Math.min(2.0, Math.max(0.2, Number(winSecondsEl?.value || 10)));
  const tMin = t1 - span;
  const slice = [];
  for (let i = d.times.length - 1; i >= d.startIdx; i--) {
    if (d.times[i] < tMin) break;
    slice.push(d.volts[i]);
  }
  return median(slice);
}

function drawAxes(ctxX, w, h, padL, padR, padT, padB, t0, t1, vMin, vMax, title) {
  const css = getComputedStyle(document.documentElement);
  const txt = css.getPropertyValue('--plot-text').trim();

  const plotW = w - padL - padR;
  const plotH = h - padT - padB;

  // background
  ctxX.clearRect(0, 0, w, h);
  ctxX.fillStyle = css.getPropertyValue('--plot-bg').trim();
  ctxX.fillRect(0, 0, w, h);

  // Grid
  ctxX.strokeStyle = css.getPropertyValue('--plot-grid').trim();
  ctxX.lineWidth = 1;

  const yTicks = 5;
  for (let i = 0; i <= yTicks; i++) {
    const y = padT + (plotH * i) / yTicks;
    ctxX.beginPath();
    ctxX.moveTo(padL, y);
    ctxX.lineTo(padL + plotW, y);
    ctxX.stroke();
  }

  const xTicks = 5;
  for (let i = 0; i <= xTicks; i++) {
    const x = padL + (plotW * i) / xTicks;
    ctxX.beginPath();
    ctxX.moveTo(x, padT);
    ctxX.lineTo(x, padT + plotH);
    ctxX.stroke();
  }

  // Axes
  ctxX.strokeStyle = css.getPropertyValue('--plot-axis').trim();
  ctxX.lineWidth = 1.5;
  ctxX.beginPath();
  ctxX.moveTo(padL, padT);
  ctxX.lineTo(padL, padT + plotH);
  ctxX.lineTo(padL + plotW, padT + plotH);
  ctxX.stroke();

  // Labels
  ctxX.fillStyle = txt;
  ctxX.font = '13px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';

  for (let i = 0; i <= yTicks; i++) {
    const frac = 1 - (i / yTicks);
    const v = vMin + frac * (vMax - vMin);
    const y = padT + (plotH * i) / yTicks;
    ctxX.fillText(v.toFixed(3), 10, y + 4);
  }

  for (let i = 0; i <= xTicks; i++) {
    const frac = i / xTicks;
    const t = t0 + frac * (t1 - t0);
    const x = padL + (plotW * i) / xTicks;
    ctxX.fillText(t.toFixed(2), x - 12, padT + plotH + 22);
  }

  ctxX.fillText(title, padL, 14);
  ctxX.fillText('Time (s)', padL + plotW - 70, padT + plotH + 38);
}

function drawTrace(ctxX, padL, padT, plotW, plotH, t0, t1, vMin, vMax, timesArr, voltsArr, startIdx, style) {
  if (!timesArr || timesArr.length - startIdx < 2) return;

  ctxX.save();
  if (style?.dash) ctxX.setLineDash(style.dash);
  ctxX.strokeStyle = style?.stroke || getComputedStyle(document.documentElement).getPropertyValue('--plot-trace').trim();
  ctxX.globalAlpha = style?.alpha ?? 1.0;
  ctxX.lineWidth = style?.lineWidth ?? 2;

  const count = timesArr.length - startIdx;
  const maxDrawPoints = Math.min(3500, count);
  const step = Math.max(1, Math.floor(count / maxDrawPoints));

  ctxX.beginPath();
  let first = true;
  for (let i = startIdx; i < timesArr.length; i += step) {
    const x = padL + ((timesArr[i] - t0) / (t1 - t0)) * plotW;
    const y = padT + (1 - (voltsArr[i] - vMin) / (vMax - vMin)) * plotH;
    if (first) { ctxX.moveTo(x, y); first = false; }
    else ctxX.lineTo(x, y);
  }
  ctxX.stroke();
  ctxX.restore();
}

function drawOverlay(clearOnly=false) {
  if (!ctx || !canvas) return;

  const w = canvas.width;
  const h = canvas.height;
  const padL = 64, padR = 14, padT = 16, padB = 42;

  // pick time window from whichever device has data
  const d0 = dev[0];
  const d1 = dev[1];
  const has0 = (d0.times.length - d0.startIdx) >= 2;
  const has1 = (d1.times.length - d1.startIdx) >= 2;

  if (clearOnly || (!has0 && !has1)) {
    const css = getComputedStyle(document.documentElement);
    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = css.getPropertyValue('--plot-bg').trim();
    ctx.fillRect(0, 0, w, h);
    ctx.fillStyle = css.getPropertyValue('--plot-text').trim();
    ctx.font = '16px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
    ctx.fillText('No data yet. Connect and start notifications…', 18, 34);
    return;
  }

  // Time bounds: use max overlap window for display (latest t1 among connected, and t0 = t1 - window)
  const t1 = Math.max(
    has0 ? d0.times[d0.times.length - 1] : -Infinity,
    has1 ? d1.times[d1.times.length - 1] : -Infinity
  );
  const winS = Math.max(1, Math.min(120, Number(winSecondsEl?.value || 10)));
  const t0 = t1 - winS;

  // Voltage range across both devices in that time window
  let vMin = Infinity, vMax = -Infinity;
  function scanRange(d) {
    for (let i = d.times.length - 1; i >= d.startIdx; i--) {
      if (d.times[i] < t0) break;
      const v = d.volts[i];
      if (v < vMin) vMin = v;
      if (v > vMax) vMax = v;
    }
  }

  scanRange(d0);
  scanRange(d1);

  if (!isFinite(vMin) || !isFinite(vMax)) { vMin = 0; vMax = 1; }

  if (autoScaleEl?.checked) {
    const span = (vMax - vMin);
    const pad = (span * 0.12) || 0.02;
    vMin -= pad; vMax += pad;
  } else {
    vMin = 0.0; vMax = 3.3;
  }

  if (vMax - vMin < 1e-9) vMax = vMin + 1e-6;

  drawAxes(ctx, w, h, padL, padR, padT, padB, t0, t1, vMin, vMax, 'Overlay (raw voltage)');

  const plotW = w - padL - padR;
  const plotH = h - padT - padB;

  // Device #1: solid
  if (has0) {
    drawTrace(ctx, padL, padT, plotW, plotH, t0, t1, vMin, vMax, d0.times, d0.volts, d0.startIdx, {
      alpha: 1.0,
      lineWidth: 2,
      dash: null,
      stroke: getComputedStyle(document.documentElement).getPropertyValue('--plot-trace').trim(),
    });
  }

  // Device #2: dashed
  if (has1) {
    drawTrace(ctx, padL, padT, plotW, plotH, t0, t1, vMin, vMax, d1.times, d1.volts, d1.startIdx, {
      alpha: 0.9,
      lineWidth: 2,
      dash: [8, 6],
      stroke: getComputedStyle(document.documentElement).getPropertyValue('--plot-trace').trim(),
    });
  }
}

function drawProcessed(clearOnly=false) {
  if (!ctxProc || !canvasProc) return;

  const w = canvasProc.width;
  const h = canvasProc.height;
  const padL = 64, padR = 14, padT = 16, padB = 42;

  const d0 = dev[0];
  const d1 = dev[1];
  const has0 = (d0.times.length - d0.startIdx) >= 2;
  const has1 = (d1.times.length - d1.startIdx) >= 2;

  if (clearOnly || (!has0 && !has1)) {
    const css = getComputedStyle(document.documentElement);
    ctxProc.clearRect(0, 0, w, h);
    ctxProc.fillStyle = css.getPropertyValue('--plot-bg').trim();
    ctxProc.fillRect(0, 0, w, h);
    ctxProc.fillStyle = css.getPropertyValue('--plot-text').trim();
    ctxProc.font = '16px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
    ctxProc.fillText('Processed plot will appear here…', 18, 34);
    return;
  }

  const t1 = Math.max(
    has0 ? d0.times[d0.times.length - 1] : -Infinity,
    has1 ? d1.times[d1.times.length - 1] : -Infinity
  );
  const winS = Math.max(1, Math.min(120, Number(winSecondsEl?.value || 10)));
  const t0 = t1 - winS;

  // Baseline per device: median of last ~2 seconds
  const b0 = has0 ? medianWindowBaseline(0) : NaN;
  const b1 = has1 ? medianWindowBaseline(1) : NaN;

  // Compute min/max of processed within time window
  let pMin = Infinity, pMax = -Infinity;

  function scanProcessed(d, b) {
    if (!isFinite(b)) b = 0;
    for (let i = d.times.length - 1; i >= d.startIdx; i--) {
      if (d.times[i] < t0) break;
      const p = d.volts[i] - b;
      if (p < pMin) pMin = p;
      if (p > pMax) pMax = p;
    }
  }

  scanProcessed(d0, b0);
  scanProcessed(d1, b1);

  if (!isFinite(pMin) || !isFinite(pMax)) { pMin = 0; pMax = 1; }

  // Shift so everything is >= 0 (your request)
  const shift = (pMin < 0) ? -pMin : 0;
  const vMin = 0;
  const vMax = (pMax + shift) + ((pMax - pMin) * 0.12 || 0.02);

  drawAxes(ctxProc, w, h, padL, padR, padT, padB, t0, t1, vMin, vMax, 'Processed (baseline removed, shifted)');

  const plotW = w - padL - padR;
  const plotH = h - padT - padB;

  function drawProcessedTrace(d, b, style) {
    if (!d || (d.times.length - d.startIdx) < 2) return;
    if (!isFinite(b)) b = 0;

    // Create lightweight processed arrays for drawing only (decimated later)
    const timesArr = d.times;
    const voltsArr = d.volts;
    const startIdx = d.startIdx;

    const count = timesArr.length - startIdx;
    const maxDrawPoints = Math.min(3500, count);
    const step = Math.max(1, Math.floor(count / maxDrawPoints));

    ctxProc.save();
    if (style?.dash) ctxProc.setLineDash(style.dash);
    ctxProc.strokeStyle = style?.stroke || getComputedStyle(document.documentElement).getPropertyValue('--plot-trace').trim();
    ctxProc.globalAlpha = style?.alpha ?? 1.0;
    ctxProc.lineWidth = style?.lineWidth ?? 2;

    ctxProc.beginPath();
    let first = true;
    for (let i = startIdx; i < timesArr.length; i += step) {
      const tt = timesArr[i];
      if (tt < t0) continue;
      const pp = (voltsArr[i] - b) + shift;
      const x = padL + ((tt - t0) / (t1 - t0)) * plotW;
      const y = padT + (1 - (pp - vMin) / (vMax - vMin)) * plotH;
      if (first) { ctxProc.moveTo(x, y); first = false; }
      else ctxProc.lineTo(x, y);
    }
    ctxProc.stroke();
    ctxProc.restore();
  }

  if (has0) drawProcessedTrace(d0, b0, { alpha: 1.0, lineWidth: 2, dash: null });
  if (has1) drawProcessedTrace(d1, b1, { alpha: 0.9, lineWidth: 2, dash: [8, 6] });
}

async function disconnectIdx(idx) {
  const d = dev[idx];
  try {
    if (d.dataChar) {
      try { await d.dataChar.stopNotifications(); } catch (_) {}
      d.dataChar.removeEventListener('characteristicvaluechanged', d._handler);
    }
  } finally {
    d.dataChar = null;
    d.server = null;
    if (d.device && d.device.gatt && d.device.gatt.connected) d.device.gatt.disconnect();
    d.device = null;
  }

  updateKPIs();
  requestDraw();
}

async function connectIdx(idx) {
  clearUiError();
  if (!supportsWebBluetooth()) {
    showUiError('Web Bluetooth not supported (use Android Chrome/Edge).');
    return;
  }

  try {
    setStatus(null, idx === 0 ? 'Opening picker (dev #1)…' : 'Opening picker (dev #2)…');

    const device = await navigator.bluetooth.requestDevice({
      filters: [{ services: [SERVICE_UUID] }],
      optionalServices: [SERVICE_UUID]
    });

    dev[idx].device = device;

    device.addEventListener('gattserverdisconnected', async () => {
      await disconnectIdx(idx);
      setStatus(false, 'Disconnected');
      btnDisconnect.disabled = !dev[0].device;
      disconnect2.disabled = !dev[1].device;
      btnConnect.disabled = !!dev[0].device;
      connect2.disabled = !!dev[1].device;
    });

    setStatus(null, idx === 0 ? 'Connecting dev #1…' : 'Connecting dev #2…');
    dev[idx].server = await device.gatt.connect();

    const service = await dev[idx].server.getPrimaryService(SERVICE_UUID);
    dev[idx].dataChar = await service.getCharacteristic(DATA_CHAR_UUID);

    dev[idx]._handler = onNotificationFactory(idx);
    await dev[idx].dataChar.startNotifications();
    dev[idx].dataChar.addEventListener('characteristicvaluechanged', dev[idx]._handler);

    setStatus(true, 'Connected + streaming');

    // button states
    btnDisconnect.disabled = !dev[0].device;
    disconnect2.disabled = !dev[1].device;
    btnConnect.disabled = !!dev[0].device;
    connect2.disabled = !!dev[1].device;

    updateKPIs();
    requestDraw();
  } catch (err) {
    console.error(err);
    setStatus(false, 'Error');
    showUiError('Connect failed: ' + (err?.message || err));
    await disconnectIdx(idx);

    btnDisconnect.disabled = !dev[0].device;
    disconnect2.disabled = !dev[1].device;
    btnConnect.disabled = !!dev[0].device;
    connect2.disabled = !!dev[1].device;
  }
}

async function disconnectAll() {
  await disconnectIdx(0);
  await disconnectIdx(1);
  setStatus(false, 'Disconnected');
  btnDisconnect.disabled = true;
  disconnect2.disabled = true;
  btnConnect.disabled = false;
  connect2.disabled = false;
}

function bindOrError() {
  const missing = [];
  if (!btnConnect) missing.push('#btnConnect');
  if (!btnDisconnect) missing.push('#btnDisconnect');
  if (!canvas || !ctx) missing.push('#plot');
  if (!canvasProc || !ctxProc) missing.push('#plotProc');
  if (missing.length) {
    showUiError('UI missing: ' + missing.join(', '));
    return;
  }

  btnConnect.onclick = () => connectIdx(0);
  btnDisconnect.onclick = () => disconnectIdx(0);

  connect2.onclick = () => connectIdx(1);
  disconnect2.onclick = () => disconnectIdx(1);

  btnClear.onclick = clearData;
  btnCsv.onclick = downloadCSV;

  btnTheme.onclick = () => {
    plotTheme = (plotTheme === 'dark') ? 'light' : 'dark';
    applyPlotTheme();
  };

  setStatus(false, 'Disconnected');
  applyPlotTheme();
  clearData();

  // Initial button states
  btnDisconnect.disabled = true;
  disconnect2.disabled = true;
  btnConnect.disabled = false;
  connect2.disabled = false;
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', bindOrError);
} else {
  bindOrError();
}
</script>
</body>
</html>
