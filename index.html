<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BLE Live Plotter</title>
  <style>
    :root {
      --bg: #0b0f19;
      --card: #121a2a;
      --text: #e7eefc;
      --muted: #a9b6d3;
      --accent: #67b7ff;
      --danger: #ff6b6b;
      --ok: #36d399;

      /* Plot theme defaults (dark) */
      --plot-bg: #070b13;
      --plot-grid: rgba(255,255,255,0.10);
      --plot-axis: rgba(255,255,255,0.20);
      --plot-text: rgba(255,255,255,0.75);

      /* Traces */
      --plot-trace: rgba(103,183,255,0.95);      /* device #1 */
      --plot-trace2: rgba(255, 80, 80, 0.95);    /* device #2 (RED) */
    }

    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background: var(--bg); color: var(--text); }
    header { padding: 14px 16px; background: rgba(255,255,255,0.03); border-bottom: 1px solid rgba(255,255,255,0.06); }
    header h1 { font-size: 16px; margin: 0; font-weight: 650; }
    header p { margin: 6px 0 0; color: var(--muted); font-size: 12px; }

    main { padding: 16px; display: grid; gap: 12px; max-width: 980px; margin: 0 auto; }
    .card { background: var(--card); border: 1px solid rgba(255,255,255,0.06); border-radius: 14px; padding: 12px; box-shadow: 0 8px 24px rgba(0,0,0,0.2); }

    .controls { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
    .controls.tight { gap: 8px; }
    button { appearance: none; border: 1px solid rgba(255,255,255,0.12); background: rgba(255,255,255,0.06); color: var(--text);
      padding: 10px 12px; border-radius: 12px; font-weight: 650; cursor: pointer; }
    button.primary { border-color: rgba(103,183,255,0.6); background: rgba(103,183,255,0.15); }
    button.danger { border-color: rgba(255,107,107,0.55); background: rgba(255,107,107,0.12); }
    button:disabled { opacity: 0.45; cursor: not-allowed; }

    .small { font-size: 12px; color: var(--muted); }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }

    .pill { display: inline-flex; align-items: center; gap: 8px; padding: 6px 10px; border-radius: 999px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.08); }
    .dot { width: 8px; height: 8px; border-radius: 50%; background: #666; }
    .dot.ok { background: var(--ok); }
    .dot.bad { background: var(--danger); }

    canvas { width: 100%; background: var(--plot-bg); border-radius: 12px; border: 1px solid rgba(255,255,255,0.06); touch-action: pan-y; }

    .kpi { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 10px; }
    .kpi .item { padding: 10px; border-radius: 12px; background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.06); }
    .kpi .label { font-size: 11px; color: var(--muted); }
    .kpi .value { font-size: 16px; font-weight: 750; margin-top: 4px; }

    .grid2 { display: grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 860px) { .grid2 { grid-template-columns: 1.2fr 0.8fr; } }

    input[type="number"] { width: 110px; padding: 9px 10px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.12); background: rgba(255,255,255,0.05); color: var(--text); }
    input[type="checkbox"] { transform: scale(1.15); }

    a { color: var(--accent); text-decoration: none; }
    .err { color: #ffd1d1; }
  </style>
</head>
<body>
  <header>
    <h1>BLE Live Plotter (ANNA-B112)</h1>
    <p>Two-device Web Bluetooth realtime overlay + rolling baseline+norm processed plot + CSV export. Parses <span class="mono">(timestamp, voltage)</span> float32 pairs.</p>
  </header>

  <main>
    <div class="card">
      <canvas id="plot" width="1400" height="480" style="height:360px;"></canvas>

      <div class="controls" style="margin-top:10px; justify-content: space-between;">
        <div class="controls tight">
          <button id="btnConnect1" class="primary" type="button">Connect #1</button>
          <button id="btnDisconnect1" class="danger" type="button" disabled>Disconnect #1</button>

          <button id="btnConnect2" class="primary" type="button">Connect #2</button>
          <button id="btnDisconnect2" class="danger" type="button" disabled>Disconnect #2</button>

          <button id="btnResetTime" type="button">Reset time (both)</button>

          <span class="pill"><span id="statusDot" class="dot"></span><span id="statusText" class="small">Disconnected</span></span>
          <span class="pill"><span class="small">Device:</span><span id="deviceName" class="mono small">—</span></span>
        </div>

        <div class="controls tight">
          <button id="btnTheme" type="button">Plot: Dark</button>
          <button id="btnClear" type="button">Clear</button>
          <button id="btnCsv" type="button">Download CSV</button>
        </div>
      </div>

      <div class="controls" style="margin-top:10px;">
        <span class="small">Window (s):</span>
        <input id="winSeconds" type="number" min="1" max="120" step="1" value="10" />
        <span class="small">Auto-scale:</span>
        <input id="autoScale" type="checkbox" checked />
        <span class="small err" id="uiError" style="display:none;"></span>
      </div>

      <div class="small" style="margin-top:10px; line-height:1.45;">
        UUIDs: <span class="mono">Service</span> <span class="mono">cddf1000-30f7-4671-8b43-5e40ba53514a</span> • <span class="mono">Notify</span> <span class="mono">cddf1002-30f7-4671-8b43-5e40ba53514a</span><br/>
        Overlay: #1 solid blue, #2 solid red. Processed: per-device rolling baseline (2 s) + robust rolling normalization (5 s, 10–90%).
      </div>

      <div class="small" style="margin-top:12px; margin-bottom:6px;">
        Processed (per-device rolling baseline + rolling robust normalization to 0–1)
      </div>
      <canvas id="plotProc" width="1400" height="320" style="height:260px;"></canvas>
    </div>

    <div class="grid2">
      <div class="card">
        <div class="kpi">
          <div class="item">
            <div class="label">Samples / s (approx)</div>
            <div class="value" id="kpiRate">—</div>
          </div>
          <div class="item">
            <div class="label">Latest voltage (active device)</div>
            <div class="value" id="kpiV">—</div>
          </div>
          <div class="item">
            <div class="label">Latest time (local)</div>
            <div class="value" id="kpiT">—</div>
          </div>
          <div class="item">
            <div class="label">Last packet (hex)</div>
            <div class="value mono" id="kpiHex" style="font-size: 12px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">—</div>
          </div>
        </div>

        <hr style="border: none; border-top: 1px solid rgba(255,255,255,0.08); margin: 14px 0;" />

        <div class="small" style="line-height:1.55;">
          <div style="font-weight:700; margin-bottom:6px;">If device #2 is hard to detect/connect</div>
          • Web Bluetooth can be picky when you use a strict <span class="mono">service filter</span>. This code now uses a <b>fallback</b>: if filtered discovery fails, it re-opens the picker with <span class="mono">acceptAllDevices</span> and then verifies your service exists.<br/>
          • Connection can fail if the peripheral is already connected to another central, or if it’s advertising too slowly. (Your ~1.3 s advertising interval can make it feel “laggy”.)
        </div>
      </div>

      <div class="card">
        <div class="small" style="line-height:1.55;">
          <div style="font-weight:700; margin-bottom:6px;">Reset time (both)</div>
          Your Python does <b>client-side</b> resets (not hardware): it starts a new segment from 0 s for display and keeps a recording offset for continuous saving. The button here mirrors that behavior for both devices.
        </div>
      </div>
    </div>
  </main>

<script>
const SERVICE_UUID = 'cddf1000-30f7-4671-8b43-5e40ba53514a';
const DATA_CHAR_UUID = 'cddf1002-30f7-4671-8b43-5e40ba53514a';

const el = (id) => document.getElementById(id);

const btnConnect1 = el('btnConnect1');
const btnDisconnect1 = el('btnDisconnect1');
const btnConnect2 = el('btnConnect2');
const btnDisconnect2 = el('btnDisconnect2');
const btnResetTime = el('btnResetTime');

const btnClear = el('btnClear');
const btnCsv = el('btnCsv');
const btnTheme = el('btnTheme');

const statusDot = el('statusDot');
const statusText = el('statusText');
const deviceNameEl = el('deviceName');
const winSecondsEl = el('winSeconds');
const autoScaleEl = el('autoScale');
const uiError = el('uiError');

const kpiRate = el('kpiRate');
const kpiV = el('kpiV');
const kpiT = el('kpiT');
const kpiHex = el('kpiHex');

const canvas = el('plot');
const ctx = canvas?.getContext('2d');
const canvasProc = el('plotProc');
const ctxProc = canvasProc?.getContext('2d');

function showUiError(msg) {
  if (!uiError) { alert(msg); return; }
  uiError.style.display = 'inline';
  uiError.textContent = msg;
}
function clearUiError() {
  if (!uiError) return;
  uiError.style.display = 'none';
  uiError.textContent = '';
}

function setStatus(ok, msg) {
  statusDot?.classList.toggle('ok', !!ok);
  statusDot?.classList.toggle('bad', ok === false);
  if (statusText) statusText.textContent = msg;
}

function supportsWebBluetooth() {
  return !!navigator.bluetooth;
}

// Plot theme
let plotTheme = 'dark';
function applyPlotTheme() {
  if (plotTheme === 'dark') {
    document.documentElement.style.setProperty('--plot-bg', '#070b13');
    document.documentElement.style.setProperty('--plot-grid', 'rgba(255,255,255,0.10)');
    document.documentElement.style.setProperty('--plot-axis', 'rgba(255,255,255,0.20)');
    document.documentElement.style.setProperty('--plot-text', 'rgba(255,255,255,0.78)');
    document.documentElement.style.setProperty('--plot-trace', 'rgba(103,183,255,0.95)');   // dev1
    document.documentElement.style.setProperty('--plot-trace2', 'rgba(255,80,80,0.95)');   // dev2
    if (btnTheme) btnTheme.textContent = 'Plot: Dark';
  } else {
    document.documentElement.style.setProperty('--plot-bg', '#ffffff');
    document.documentElement.style.setProperty('--plot-grid', 'rgba(0,0,0,0.12)');
    document.documentElement.style.setProperty('--plot-axis', 'rgba(0,0,0,0.22)');
    document.documentElement.style.setProperty('--plot-text', 'rgba(0,0,0,0.78)');
    document.documentElement.style.setProperty('--plot-trace', 'rgba(10,60,140,0.95)');    // dev1
    document.documentElement.style.setProperty('--plot-trace2', 'rgba(200,0,0,0.95)');      // dev2
    if (btnTheme) btnTheme.textContent = 'Plot: Light';
  }
  requestDraw();
}

// ===== Two-device state =====
const DEV_N = 2;
const dev = Array.from({length: DEV_N}, () => ({
  device: null,
  server: null,
  dataChar: null,
  handler: null,

  // session storage (CSV)
  sessionLocalT: [],        // segment time (resets on "Reset time")
  sessionLocalTCont: [],    // continuous time (segment + recordingOffset)
  sessionRawT: [],
  sessionV: [],             // raw voltage (top plot)
  sessionProc: [],          // baseline removed (bottom plot)
  sessionNorm: [],          // normalized 0..1 (bottom plot)

  recordingOffset: 0,       // like your Python recording_offset

  // rolling for plot (local timebase)
  times: [],                // segment time for display
  volts: [],
  startIdx: 0,

  t0LocalMs: null,
  sampleTimesMs: [],
  lastHex: '',
  lastLocalT: NaN,
  lastV: NaN,
}));

// --- processing parameters (per device, rolling) ---
const BASELINE_WIN_S = 2.0; // baseline = median of last N seconds
const NORM_WIN_S = 5.0;     // normalization computed from last N seconds
const NORM_Q_LO = 0.10;     // robust percentiles
const NORM_Q_HI = 0.90;

// Render throttle
let drawPending = false;
function requestDraw() {
  if (drawPending) return;
  drawPending = true;
  requestAnimationFrame(() => {
    drawPending = false;
    drawOverlay();
    drawProcessed();
  });
}

function toHex(u8) {
  let s = '';
  for (const b of u8) s += b.toString(16).padStart(2,'0');
  return s;
}

function median(arr) {
  if (!arr.length) return NaN;
  const a = arr.slice().sort((x,y)=>x-y);
  const m = Math.floor(a.length/2);
  return (a.length % 2) ? a[m] : (a[m-1] + a[m]) / 2;
}

function quantile(sortedArr, q) {
  const n = sortedArr.length;
  if (!n) return NaN;
  const pos = (n - 1) * q;
  const base = Math.floor(pos);
  const rest = pos - base;
  if (sortedArr[base + 1] === undefined) return sortedArr[base];
  return sortedArr[base] + rest * (sortedArr[base + 1] - sortedArr[base]);
}
function clamp01(x) { return x < 0 ? 0 : (x > 1 ? 1 : x); }

function rollingBaseline(di, t1) {
  const d = dev[di];
  const tMin = t1 - BASELINE_WIN_S;
  const slice = [];
  for (let i = d.times.length - 1; i >= d.startIdx; i--) {
    if (d.times[i] < tMin) break;
    slice.push(d.volts[i]);
  }
  const b = median(slice);
  return isFinite(b) ? b : 0;
}

function rollingNormParams(di, t1, base) {
  const d = dev[di];
  const tMin = t1 - NORM_WIN_S;
  const slice = [];
  for (let i = d.times.length - 1; i >= d.startIdx; i--) {
    if (d.times[i] < tMin) break;
    const p = d.volts[i] - base;
    if (isFinite(p)) slice.push(p);
  }
  slice.sort((a,b)=>a-b);

  let lo = quantile(slice, NORM_Q_LO);
  let hi = quantile(slice, NORM_Q_HI);
  let denom = hi - lo;

  if (!isFinite(lo) || !isFinite(hi) || Math.abs(denom) < 1e-9) {
    const mn = slice.length ? slice[0] : 0;
    const mx = slice.length ? slice[slice.length - 1] : 1;
    lo = isFinite(mn) ? mn : 0;
    hi = isFinite(mx) ? mx : 1;
    denom = hi - lo;
  }
  if (!isFinite(denom) || Math.abs(denom) < 1e-9) denom = 1;

  return { lo, denom };
}

function addSample(idx, tRaw, v) {
  const d = dev[idx];
  const nowMs = performance.now();
  if (d.t0LocalMs === null) d.t0LocalMs = nowMs;

  const tLocal = (nowMs - d.t0LocalMs) / 1000.0;  // segment time (resets on Reset time)
  const tCont  = tLocal + d.recordingOffset;       // continuous time like Python

  // rolling plot buffers (segment time)
  d.times.push(tLocal);
  d.volts.push(v);

  d.lastLocalT = tLocal;
  d.lastV = v;

  // maintain visible window index
  const winS = Math.max(1, Math.min(120, Number(winSecondsEl?.value || 10)));
  const tMinPlot = tLocal - winS;
  while (d.startIdx < d.times.length && d.times[d.startIdx] < tMinPlot) d.startIdx++;

  // avoid unbounded growth
  if (d.startIdx > 4000) {
    d.times = d.times.slice(d.startIdx);
    d.volts = d.volts.slice(d.startIdx);
    d.startIdx = 0;
  }

  // per-device rolling processing (uses recent history only)
  const base = rollingBaseline(idx, tLocal);
  const proc = v - base;
  const np = rollingNormParams(idx, tLocal, base);
  const norm = clamp01((proc - np.lo) / np.denom);

  // session arrays (CSV)
  d.sessionLocalT.push(tLocal);
  d.sessionLocalTCont.push(tCont);
  d.sessionRawT.push(tRaw);
  d.sessionV.push(v);
  d.sessionProc.push(proc);
  d.sessionNorm.push(norm);

  // sample rate estimate
  d.sampleTimesMs.push(nowMs);
  const cutoff = nowMs - 2000;
  while (d.sampleTimesMs.length && d.sampleTimesMs[0] < cutoff) d.sampleTimesMs.shift();
}

function onNotificationFactory(idx) {
  return (event) => {
    const dv = event?.target?.value;
    if (!dv || dv.byteLength < 8) return;

    const bytes = new Uint8Array(dv.buffer.slice(dv.byteOffset, dv.byteOffset + dv.byteLength));
    dev[idx].lastHex = toHex(bytes);

    // Parse multiple samples packed into one notification (8 bytes per sample)
    const n = Math.floor(dv.byteLength / 8);
    for (let i = 0; i < n; i++) {
      const off = i * 8;
      const t = dv.getFloat32(off + 0, true);
      const v = dv.getFloat32(off + 4, true);
      addSample(idx, t, v);
    }

    updateKPIs(idx);
    requestDraw();
  };
}

function updateKPIs(activeIdx) {
  const d = dev[activeIdx];
  const rate = (d.sampleTimesMs.length / 2);
  if (kpiRate) kpiRate.textContent = isFinite(rate) ? rate.toFixed(1) : '—';
  if (kpiV) kpiV.textContent = isFinite(d.lastV) ? d.lastV.toFixed(4) + ' V' : '—';
  if (kpiT) kpiT.textContent = isFinite(d.lastLocalT) ? d.lastLocalT.toFixed(3) + ' s' : '—';
  if (kpiHex) kpiHex.textContent = d.lastHex || '—';

  const name1 = dev[0].device?.name || '';
  const name2 = dev[1].device?.name || '';
  const label = [name1, name2].filter(Boolean).join(' + ') || '—';
  if (deviceNameEl) deviceNameEl.textContent = label;
}

function clearData() {
  for (let i = 0; i < DEV_N; i++) {
    const d = dev[i];
    d.sessionLocalT.length = 0;
    d.sessionLocalTCont.length = 0;
    d.sessionRawT.length = 0;
    d.sessionV.length = 0;
    d.sessionProc.length = 0;
    d.sessionNorm.length = 0;

    d.recordingOffset = 0;

    d.times = [];
    d.volts = [];
    d.startIdx = 0;

    d.t0LocalMs = null;
    d.sampleTimesMs = [];
    d.lastHex = '';
    d.lastLocalT = NaN;
    d.lastV = NaN;
  }

  if (kpiRate) kpiRate.textContent = '—';
  if (kpiV) kpiV.textContent = '—';
  if (kpiT) kpiT.textContent = '—';
  if (kpiHex) kpiHex.textContent = '—';
  if (deviceNameEl) deviceNameEl.textContent = '—';

  drawOverlay(true);
  drawProcessed(true);
}

/**
 * This mirrors your Python behavior (client-side reset, not hardware):
 * - recordingOffset += last segment duration (so CSV can be continuous)
 * - clear display buffers (times/volts)
 * - reset local time origin so new segment starts at 0 s (for both devices)
 */
function resetTimebaseBoth() {
  const now = performance.now();
  for (let i = 0; i < DEV_N; i++) {
    const d = dev[i];

    if (d.times.length) {
      const lastSegT = d.times[d.times.length - 1];
      if (isFinite(lastSegT) && lastSegT > 0) d.recordingOffset += lastSegT;
    }

    d.times = [];
    d.volts = [];
    d.startIdx = 0;

    if (d.device) d.t0LocalMs = now;
    d.sampleTimesMs = [];
  }
  setStatus(true, 'Time reset (both) — new segment starts at 0 s');
  requestDraw();
}

function downloadCSV() {
  const n1 = dev[0].sessionLocalT.length;
  const n2 = dev[1].sessionLocalT.length;
  const n = Math.max(n1, n2);
  if (!n) { alert('No data to export yet.'); return; }

  const name1 = dev[0].device?.name || 'dev1';
  const name2 = dev[1].device?.name || 'dev2';

  const header = [
    // Device 1 (Top + Bottom box columns)
    `${name1}_seg_time_s`, `${name1}_cont_time_s`, `${name1}_raw_time_s`,
    `${name1}_raw_V`, `${name1}_proc_baselineRemoved`, `${name1}_norm_0_1`,
    // Device 2 (Top + Bottom box columns)
    `${name2}_seg_time_s`, `${name2}_cont_time_s`, `${name2}_raw_time_s`,
    `${name2}_raw_V`, `${name2}_proc_baselineRemoved`, `${name2}_norm_0_1`,
  ];

  const lines = [header.join(',')];

  function cell(x) {
    if (x === null || x === undefined) return '';
    if (typeof x === 'number') return (isFinite(x) ? String(x) : '');
    return String(x).replace(/"/g,'""');
  }

  for (let i = 0; i < n; i++) {
    const row = [];

    // dev1
    row.push(cell(dev[0].sessionLocalT[i]));
    row.push(cell(dev[0].sessionLocalTCont[i]));
    row.push(cell(dev[0].sessionRawT[i]));
    row.push(cell(dev[0].sessionV[i]));
    row.push(cell(dev[0].sessionProc[i]));
    row.push(cell(dev[0].sessionNorm[i]));

    // dev2
    row.push(cell(dev[1].sessionLocalT[i]));
    row.push(cell(dev[1].sessionLocalTCont[i]));
    row.push(cell(dev[1].sessionRawT[i]));
    row.push(cell(dev[1].sessionV[i]));
    row.push(cell(dev[1].sessionProc[i]));
    row.push(cell(dev[1].sessionNorm[i]));

    lines.push(row.join(','));
  }

  const blob = new Blob([lines.join('\n')], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  const ts = new Date().toISOString().replace(/[:.]/g,'-');
  a.download = `ble_samples_aligned_${ts}.csv`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

function drawAxes(ctxX, w, h, padL, padR, padT, padB, t0, t1, vMin, vMax, title) {
  const css = getComputedStyle(document.documentElement);
  const txt = css.getPropertyValue('--plot-text').trim();

  const plotW = w - padL - padR;
  const plotH = h - padT - padB;

  ctxX.clearRect(0, 0, w, h);
  ctxX.fillStyle = css.getPropertyValue('--plot-bg').trim();
  ctxX.fillRect(0, 0, w, h);

  // Grid
  ctxX.strokeStyle = css.getPropertyValue('--plot-grid').trim();
  ctxX.lineWidth = 1;

  const yTicks = 5;
  for (let i = 0; i <= yTicks; i++) {
    const y = padT + (plotH * i) / yTicks;
    ctxX.beginPath();
    ctxX.moveTo(padL, y);
    ctxX.lineTo(padL + plotW, y);
    ctxX.stroke();
  }

  const xTicks = 5;
  for (let i = 0; i <= xTicks; i++) {
    const x = padL + (plotW * i) / xTicks;
    ctxX.beginPath();
    ctxX.moveTo(x, padT);
    ctxX.lineTo(x, padT + plotH);
    ctxX.stroke();
  }

  // Axes
  ctxX.strokeStyle = css.getPropertyValue('--plot-axis').trim();
  ctxX.lineWidth = 1.5;
  ctxX.beginPath();
  ctxX.moveTo(padL, padT);
  ctxX.lineTo(padL, padT + plotH);
  ctxX.lineTo(padL + plotW, padT + plotH);
  ctxX.stroke();

  // Labels
  ctxX.fillStyle = txt;
  ctxX.font = '13px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';

  for (let i = 0; i <= yTicks; i++) {
    const frac = 1 - (i / yTicks);
    const v = vMin + frac * (vMax - vMin);
    const y = padT + (plotH * i) / yTicks;
    ctxX.fillText(v.toFixed(3), 10, y + 4);
  }
  ctxX.fillText('Voltage', 10, 14);

  for (let i = 0; i <= xTicks; i++) {
    const frac = i / xTicks;
    const t = t0 + frac * (t1 - t0);
    const x = padL + (plotW * i) / xTicks;
    ctxX.fillText(t.toFixed(2), x - 12, padT + plotH + 22);
  }
  ctxX.fillText('Time (s)', padL + plotW - 70, padT + plotH + 38);

  ctxX.fillText(title, padL, 14);
}

function drawTrace(ctxX, padL, padT, plotW, plotH, t0, t1, vMin, vMax, timesArr, voltsArr, startIdx, colorCssVar) {
  const count = timesArr.length - startIdx;
  if (count < 2) return;

  const css = getComputedStyle(document.documentElement);
  ctxX.save();
  ctxX.strokeStyle = css.getPropertyValue(colorCssVar).trim();
  ctxX.lineWidth = 2;
  ctxX.setLineDash([]); // solid

  const maxDrawPoints = Math.min(4000, count);
  const step = Math.max(1, Math.floor(count / maxDrawPoints));

  ctxX.beginPath();
  let first = true;
  for (let i = startIdx; i < timesArr.length; i += step) {
    const tt = timesArr[i];
    if (tt < t0) continue;
    const x = padL + ((tt - t0) / (t1 - t0)) * plotW;
    const y = padT + (1 - (voltsArr[i] - vMin) / (vMax - vMin)) * plotH;
    if (first) { ctxX.moveTo(x, y); first = false; }
    else ctxX.lineTo(x, y);
  }
  ctxX.stroke();
  ctxX.restore();
}

function drawOverlay(clearOnly=false) {
  if (!ctx || !canvas) return;

  const w = canvas.width, h = canvas.height;
  const padL = 64, padR = 14, padT = 16, padB = 42;

  const has0 = (dev[0].times.length - dev[0].startIdx) >= 2;
  const has1 = (dev[1].times.length - dev[1].startIdx) >= 2;

  if (clearOnly || (!has0 && !has1)) {
    const css = getComputedStyle(document.documentElement);
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = css.getPropertyValue('--plot-bg').trim();
    ctx.fillRect(0,0,w,h);
    ctx.fillStyle = css.getPropertyValue('--plot-text').trim();
    ctx.font = '16px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
    ctx.fillText('No data yet. Connect and start notifications…', 18, 34);
    return;
  }

  const t1 = Math.max(
    has0 ? dev[0].times[dev[0].times.length - 1] : -Infinity,
    has1 ? dev[1].times[dev[1].times.length - 1] : -Infinity
  );
  const winS = Math.max(1, Math.min(120, Number(winSecondsEl?.value || 10)));
  const t0 = t1 - winS;

  // Voltage range across both devices in window
  let vMin = Infinity, vMax = -Infinity;
  for (let di = 0; di < DEV_N; di++) {
    const d = dev[di];
    for (let i = d.times.length - 1; i >= d.startIdx; i--) {
      if (d.times[i] < t0) break;
      const v = d.volts[i];
      if (v < vMin) vMin = v;
      if (v > vMax) vMax = v;
    }
  }
  if (!isFinite(vMin) || !isFinite(vMax)) { vMin = 0; vMax = 1; }

  if (autoScaleEl?.checked) {
    const span = (vMax - vMin);
    const pad = (span * 0.12) || 0.02;
    vMin -= pad; vMax += pad;
  } else {
    vMin = 0.0; vMax = 3.3;
  }
  if (vMax - vMin < 1e-9) vMax = vMin + 1e-6;

  drawAxes(ctx, w, h, padL, padR, padT, padB, t0, t1, vMin, vMax, 'Overlay (raw voltage)');
  const plotW = w - padL - padR;
  const plotH = h - padT - padB;

  if (has0) drawTrace(ctx, padL, padT, plotW, plotH, t0, t1, vMin, vMax, dev[0].times, dev[0].volts, dev[0].startIdx, '--plot-trace');
  if (has1) drawTrace(ctx, padL, padT, plotW, plotH, t0, t1, vMin, vMax, dev[1].times, dev[1].volts, dev[1].startIdx, '--plot-trace2');
}

function drawProcessed(clearOnly=false) {
  if (!ctxProc || !canvasProc) return;

  const w = canvasProc.width, h = canvasProc.height;
  const padL = 64, padR = 14, padT = 16, padB = 42;

  const has0 = (dev[0].times.length - dev[0].startIdx) >= 2;
  const has1 = (dev[1].times.length - dev[1].startIdx) >= 2;

  if (clearOnly || (!has0 && !has1)) {
    const css = getComputedStyle(document.documentElement);
    ctxProc.clearRect(0,0,w,h);
    ctxProc.fillStyle = css.getPropertyValue('--plot-bg').trim();
    ctxProc.fillRect(0,0,w,h);
    ctxProc.fillStyle = css.getPropertyValue('--plot-text').trim();
    ctxProc.font = '16px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
    ctxProc.fillText('Processed plot will appear here…', 18, 34);
    return;
  }

  const t1 = Math.max(
    has0 ? dev[0].times[dev[0].times.length - 1] : -Infinity,
    has1 ? dev[1].times[dev[1].times.length - 1] : -Infinity
  );
  const winS = Math.max(1, Math.min(120, Number(winSecondsEl?.value || 10)));
  const t0 = t1 - winS;

  // axes fixed 0..1 because we normalize
  drawAxes(ctxProc, w, h, padL, padR, padT, padB, t0, t1, 0, 1, 'Processed (per-device rolling baseline + rolling norm 0–1)');
  const plotW = w - padL - padR;
  const plotH = h - padT - padB;

  function drawNorm(di, colorCssVar) {
    const d = dev[di];
    const count = d.times.length - d.startIdx;
    if (count < 2) return;

    // current rolling params (per device)
    const base = rollingBaseline(di, t1);
    const np = rollingNormParams(di, t1, base);

    const css = getComputedStyle(document.documentElement);
    ctxProc.save();
    ctxProc.strokeStyle = css.getPropertyValue(colorCssVar).trim();
    ctxProc.lineWidth = 2;
    ctxProc.setLineDash([]);

    const maxDrawPoints = Math.min(4000, count);
    const step = Math.max(1, Math.floor(count / maxDrawPoints));

    ctxProc.beginPath();
    let first = true;
    for (let i = d.startIdx; i < d.times.length; i += step) {
      const tt = d.times[i];
      if (tt < t0) continue;

      const proc = d.volts[i] - base;
      const norm = clamp01((proc - np.lo) / np.denom);

      const x = padL + ((tt - t0) / (t1 - t0)) * plotW;
      const y = padT + (1 - norm) * plotH;

      if (first) { ctxProc.moveTo(x, y); first = false; }
      else ctxProc.lineTo(x, y);
    }
    ctxProc.stroke();
    ctxProc.restore();
  }

  if (has0) drawNorm(0, '--plot-trace');
  if (has1) drawNorm(1, '--plot-trace2');
}

async function disconnectIdx(idx) {
  const d = dev[idx];
  try {
    if (d.dataChar && d.handler) {
      try { await d.dataChar.stopNotifications(); } catch (_) {}
      d.dataChar.removeEventListener('characteristicvaluechanged', d.handler);
    }
  } finally {
    d.dataChar = null;
    d.server = null;
    d.handler = null;
    if (d.device && d.device.gatt && d.device.gatt.connected) d.device.gatt.disconnect();
    d.device = null;
  }
  updateButtons();
  requestDraw();
}

function updateButtons() {
  btnDisconnect1.disabled = !dev[0].device;
  btnDisconnect2.disabled = !dev[1].device;
  btnConnect1.disabled = !!dev[0].device;
  btnConnect2.disabled = !!dev[1].device;

  const any = !!dev[0].device || !!dev[1].device;
  if (!any) setStatus(false, 'Disconnected');
}

// ---------- Connection robustness helpers ----------
const sleep = (ms) => new Promise(r => setTimeout(r, ms));

async function gattConnectWithRetry(device, attempts=4) {
  let lastErr = null;
  for (let i = 0; i < attempts; i++) {
    try {
      // If already connected, reuse it
      if (device.gatt?.connected) return device.gatt;
      const server = await device.gatt.connect();
      return server;
    } catch (e) {
      lastErr = e;
      await sleep(250 + i * 350);
    }
  }
  throw lastErr;
}

async function getServiceAndCharWithRetry(server, attempts=4) {
  let lastErr = null;
  for (let i = 0; i < attempts; i++) {
    try {
      const service = await server.getPrimaryService(SERVICE_UUID);
      const ch = await service.getCharacteristic(DATA_CHAR_UUID);
      return { service, ch };
    } catch (e) {
      lastErr = e;
      await sleep(250 + i * 350);
    }
  }
  throw lastErr;
}

// Request device with a strict filter first; fallback to acceptAllDevices
async function requestDeviceWithFallback(idx) {
  // Attempt 1: strict filter (can fail to show devices sometimes)
  try {
    setStatus(null, `Picker (#${idx+1})… (filtered by service)`);
    return await navigator.bluetooth.requestDevice({
      filters: [{ services: [SERVICE_UUID] }],
      optionalServices: [SERVICE_UUID]
    });
  } catch (e) {
    // NotFoundError is common if nothing matches / browser doesn't show it
    // Fall back to acceptAllDevices so user can still pick it, then we verify service exists.
    setStatus(null, `Picker (#${idx+1})… (fallback: show all)`);
    return await navigator.bluetooth.requestDevice({
      acceptAllDevices: true,
      optionalServices: [SERVICE_UUID]
    });
  }
}

async function connectIdx(idx) {
  clearUiError();

  if (!supportsWebBluetooth()) {
    showUiError('Web Bluetooth not supported (use Android Chrome/Edge).');
    return;
  }

  // If you accidentally try to connect same device twice
  if (dev[idx].device) return;

  try {
    const device = await requestDeviceWithFallback(idx);

    // Avoid picking the same peripheral for #1 and #2
    const otherIdx = (idx === 0) ? 1 : 0;
    if (dev[otherIdx].device && dev[otherIdx].device.id === device.id) {
      showUiError('You selected the same device for #1 and #2. Pick the other ring/device.');
      return;
    }

    dev[idx].device = device;

    device.addEventListener('gattserverdisconnected', async () => {
      await disconnectIdx(idx);
      setStatus(false, 'Disconnected');
    });

    setStatus(null, `Connecting (#${idx+1})…`);
    const server = await gattConnectWithRetry(device, 4);
    dev[idx].server = server;

    setStatus(null, `Discovering service/char (#${idx+1})…`);
    const { ch } = await getServiceAndCharWithRetry(server, 4);
    dev[idx].dataChar = ch;

    // Subscribe
    setStatus(null, `Subscribing (#${idx+1})…`);
    dev[idx].handler = onNotificationFactory(idx);
    await dev[idx].dataChar.startNotifications();
    dev[idx].dataChar.addEventListener('characteristicvaluechanged', dev[idx].handler);

    setStatus(true, `Connected (#${idx+1}) + streaming`);
    updateButtons();

    updateKPIs(idx);
    requestDraw();
  } catch (err) {
    console.error(err);
    setStatus(false, 'Error');
    showUiError('Connect failed: ' + (err?.message || err) + '\n\nTip: make sure the other device is not already connected to your phone/PC, and keep it close.');
    await disconnectIdx(idx);
  }
}

// Bind
function bindOrError() {
  const missing = [];
  if (!btnConnect1) missing.push('#btnConnect1');
  if (!btnDisconnect1) missing.push('#btnDisconnect1');
  if (!btnConnect2) missing.push('#btnConnect2');
  if (!btnDisconnect2) missing.push('#btnDisconnect2');
  if (!btnResetTime) missing.push('#btnResetTime');
  if (!canvas || !ctx) missing.push('#plot');
  if (!canvasProc || !ctxProc) missing.push('#plotProc');
  if (missing.length) {
    showUiError('UI missing: ' + missing.join(', '));
    return;
  }

  btnConnect1.onclick = () => connectIdx(0);
  btnDisconnect1.onclick = () => disconnectIdx(0);
  btnConnect2.onclick = () => connectIdx(1);
  btnDisconnect2.onclick = () => disconnectIdx(1);

  btnResetTime.onclick = resetTimebaseBoth;

  btnClear.onclick = clearData;
  btnCsv.onclick = downloadCSV;

  btnTheme.onclick = () => {
    plotTheme = (plotTheme === 'dark') ? 'light' : 'dark';
    applyPlotTheme();
  };

  setStatus(false, 'Disconnected');
  applyPlotTheme();
  clearData();
  updateButtons();
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', bindOrError);
} else {
  bindOrError();
}
</script>
</body>
</html>
